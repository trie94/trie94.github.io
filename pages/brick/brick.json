{
    "title": "Brick",
    "thumb":"Collaborative multi-player mobile AR game",
    "tags":"Mobile AR, Multi-player, Google AR Core, Cloud Anchor",
    "link":"/brick",
    "blog":"https://brickisunderconstruction.wordpress.com/",
    "repo":"https://github.com/trie94/Love-Brick",
    "prototype":"",
    "twitter":"https://twitter.com/157crush/status/1074142994566144001",
    "src": "https://www.youtube.com/embed/6DIVVlTO9Uw",
    "summary": "Brick is a collaborative game in which two players work together to fill in a pattern of empty slots in a grid, using virtual blocks that are scattered all over the room.",
    "list_summary":"I worked as a solo programmer in a four-member team with UX researchers and designers. I implemented multiple interactions and networked two mobile devices using Google's AR Core and Cloud Anchor API in order to achieve a multi-player experience. Click to see more details!",
    "duration": "15-week of pre-production & 15-week of development",
    "role": "Programmer",
    "platform": "Mobile devices that support Google AR Core",
    "tool": "Unity, UNet, Google AR Core, and Google Cloud Anchor",
    "section1": "Brick has a simple game mechanic where players grab a block that is floating around in a room and match it to the slot that has the same color. Some of the blocks need to be collected individually, while others must be collected by both players working together. To win, the players must fill in the entire pattern before time runs out.",
    "section2":"The blocks come in four colors, and each player can interact with two of those colors. Each individual block has one color; each collaborative brick has two colors, one from each player. Assigned colors are shown on the screen.",
    "section3":"The host scans the floor in order to create and save a Google Cloud anchor. When the anchor is successfully saved, the host can intiate the game by clicking on the start button. Once the game has started, the timer counts down, and both players can check the time on the screen.",
    "section4":"During gameplay, players collect blocks from around the room and carry them to appropriate slots on the pattern. This involves three principal interactionsâ€“pick up, carry, and drop off. Players can collect and transport blocks using a tap-and-hold interaction. They should approach to the block until it glows and shivers, which enables players to grab it. Once they grab the block, they are able to either transport to the pattern and match it to the slot, or drop it to grab another block.",
    "section5":"In order to sync the blocks' position and rotation, a custom network transform is used, since each player instance of the game is in a different coordinate space. The custom network transform is used to position and rotate the blocks relative to the Google ARCore cloud anchor, which behaves as a world pivot.",
    "section6":"Following code snippets show how the network writer serializes transform data relative to the anchor, how the network reader unserializes it to the player's world coordinate, and lerps the blocks' position and rotation to the target position and rotation.",
    "section7":"In order to encourage collaboration, combined block interaction has been added. Each player grabs a half piece of the block; gets close to each other to make the pieces a complete combined block. Once they make the block combined, they carry it to the correct slot while keeping the distance between each other. The block can be detached if the players fail to keep their distance close.\n To help players understand that the half pieces should be combined, the affordance of a puzzle piece has been applied to the design of the block pieces.",
    "code1":"void SerializeModeTransform(NetworkWriter writer)\n{\n\twriter.Write(anchor.InverseTransformPoint(transform.position));\n\t&hellip;\n\tSerializeRotation3D(writer, Quaternion.Inverse(anchor.rotation) * transform.rotation, syncRotationAxis, rotationSyncCompression);\n\t&hellip;\n}",
    "code2":"void UnserializeModeTransform(NetworkReader reader, bool initialState)\n{\n\t&hellip;\n\tvar pos = reader.ReadVector3();\n\tm_TargetSyncPosition = anchor.TransformPoint(pos);\n\n\t&hellip;\n\tvar rot = UnserializeRotation3D(reader, syncRotationAxis, rotationSyncCompression);\n\tm_TargetSyncRotation3D = anchor.rotation * rot;\n\n\t&hellip;\n}",
    "code3":"void Update()\n{\n\t&hellip;\n\ttransform.position = Vector3.Lerp(transform.position, m_TargetSyncPosition, m_InterpolateMovement);\n\ttransform.rotation = Quaternion.Slerp(transform.rotation, m_TargetSyncRotation3D, m_InterpolateRotation);\n}"
}
