{
    "title": "BRICK",
    "thumb":"Collaborative multi-player mobile AR game",
    "tags":"Mobile AR, Multi-player, Google AR Core, Cloud Anchor",
    "link":"/brick",
    "src": "https://www.youtube.com/embed/bIKvJv66u5Y?rel=0",
    "summary": "Brick is a collaborative game in which two players work together to fill in a pattern of empty slots in a grid, using virtual blocks that are scattered all over the room.",
    "duration": "15 weeks",
    "role": "Programmer",
    "platform": "Mobile devices that support Google AR Core",
    "tool": "Unity, UNet, Google AR Core, and Google Cloud Anchor",
    "section1": "Brick has a simple game mechanic where players grab a block that is floating around in a room and match it to the slot that has the same color. Some of the blocks need to be collected individually, while others must be collected by both players working together. To win, the players must fill in the entire pattern before time runs out.",
    "section2": "The blocks come in four colors, and each player can interact with two of those colors. Each individual block has one color; each collaborative brick has two colors, one from each player. Assigned colors are shown on the screen.",
    "section3": "The host should scan the floor in order to create and save a Google Cloud anchor. When the anchor is successfully saved, the host can intiate the game by clicking on the start button. Once the game has started, the timer counts down, and both players can check the time on the screen.",
    "section4": "During gameplay, players collect blocks from around the room and carry them to appropriate slots on the pattern. This involves three principal interactionsâ€“pick up, carry, and drop off. Players can collect and transport blocks using a tap-and-hold interaction. They should approach to the block until it glows and shivers, which enables players to grab it. Once they grab the block, they are able to either transport to the pattern and match it to the slot, or drop it to grab another block.",
    "section5":"In order to sync the blocks' position and rotation, a custom network transform is used, since each player instance of the game is in a different coordinate space. The custom network transform is used to position and rotate the blocks relative to the Google ARCore cloud anchor, which behaves as a world pivot.",
    "section6":"Following code snippets show how the network writer serializes transform data relative to the anchor, how the network reader unserializes it to the player's world coordinate, and lerps the object's position and rotation to the target position and rotation.",
    "code1":"void SerializeModeTransform(NetworkWriter writer)\n{\n\twriter.Write(anchor.InverseTransformPoint(transform.position));\n\tif (m_SyncRotationAxis != AxisSyncMode.None)\n\t{\n\t\tSerializeRotation3D(writer, Quaternion.Inverse(anchor.rotation) * transform.rotation, syncRotationAxis, rotationSyncCompression);\n\t}\n \t&hellip;\n}",
    "code2":"void UnserializeModeTransform(NetworkReader reader, bool initialState)\n{\n\t&hellip;\n\tvar pos = reader.ReadVector3();\n\tm_TargetSyncPosition = anchor.TransformPoint(pos);\n\n\tif (syncRotationAxis != AxisSyncMode.None)\n\t{\n\t\tvar rot = UnserializeRotation3D(reader, syncRotationAxis, rotationSyncCompression);\n\t\tm_TargetSyncRotation3D = anchor.rotation * rot;\n\t}\n\t&hellip;\n}",
    "code3":"void Update()\n{\n\t&hellip;\n\ttransform.position = Vector3.Lerp(transform.position, m_TargetSyncPosition, m_InterpolateMovement);\n\ttransform.rotation = Quaternion.Slerp(transform.rotation, m_TargetSyncRotation3D, m_InterpolateRotation);\n}"
}